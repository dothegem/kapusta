<?xml version="1.0" encoding="UTF-8"?>
<semanticCodeSchema version="4.0">

  <meta>
    <purpose>
      <![CDATA[
      Этот XML-документ является мета-инструкцией для AI-агента по генерации и редактированию кода. 
      Он определяет структуру, семантику и правила генерации комментариев и кода.
      Секции <template> содержат конечный текстовый формат, который вставляется в файл.
      Тег <trigger> определяет семантическое условие, при котором соответствующая секция должна быть сгенерирована.
      ]]>
    </purpose>
    <guidelines_for_ai>
      <![CDATA[
      1.  Ты — AI-агент, твоя задача — следовать этой схеме.
      2.  Проанализируй задачу и реши, какие опциональные блоки (<trigger>) необходимо сгенерировать.
      3.  Не генерируй избыточную информацию. Если функция простая, ее контракт должен быть минимальным.
      4.  После генерации или модификации сложного кода, заполни секцию <ai_reflection>. Это твой долг перед будущими AI-агентами.
      ]]>
    </guidelines_for_ai>
  </meta>

  <!-- =================================================================== -->
  <!-- ==                   ОПРЕДЕЛЕНИЕ СТРУКТУРЫ МОДУЛЯ                  == -->
  <!-- =================================================================== -->
  <module>
    <purpose>Определяет высокоуровневую структуру и метаданные всего файла (.py).</purpose>

    <module_contract>
      <purpose>Обязательный "паспорт" модуля, его главная идентификационная карточка.</purpose>
      <trigger>Всегда генерируется для нового файла.</trigger>
      <template>
        <![CDATA[
# FILE: [путь/к/файлу/от/корня/проекта.py]
# VERSION: [Версия файла, например, 1.2.1]
# START_MODULE_CONTRACT:
# PURPOSE: [Краткое описание основной ответственности и цели этого модуля на русском языке.]
# SCOPE: [Основные функциональные области или домены, за которые отвечает модуль.]
# INPUT: [Описание входных данных для модуля в целом (часто "Переменные окружения" или "Нет").]
# OUTPUT: [Описание того, что модуль предоставляет системе (классы, функции, константы).]
# KEYWORDS_MODULE: [domain1, technology2, core_concept3]
# LINKS_TO_MODULE: [external_module1.py, service_api_endpoint, related_module2.py]
# LINKS_TO_SPECIFICATION: [Названия пунктов ТЗ, которые реализует модуль.]
# END_MODULE_CONTRACT
        ]]>
      </template>
    </module_contract>

    <module_map>
      <purpose>Структурное "оглавление" модуля для быстрой навигации и планирования генерации.</purpose>
      <trigger>Всегда генерируется для нового файла. Обновляется при добавлении/удалении сущностей.</trigger>
      <template>
        <![CDATA[
# START_MODULE_MAP:
# (Формат: ТИП [Вес важности 1-10] [Краткое описание] => [имя_сущности])
# END_MODULE_MAP
        ]]>
      </template>
    </module_map>

    <use_cases>
      <purpose>Связывает код с бизнес-логикой через описание ключевых сценариев использования.</purpose>
      <trigger>Генерируется, если модуль является ключевым участником сложных, многошаговых или неочевидных системных/пользовательских сценариев.</trigger>
      <template>
        <![CDATA[
# START_USE_CASES:
# (AAG-нотация: Actor (Context) -> Action (Component's Role) -> Goal)
# - [FeatureName]: [Actor (Context)] -> [Action] -> [Goal]
# END_USE_CASES
        ]]>
      </template>
    </use_cases>

    <change_summary>
      <purpose>Отслеживает эволюцию модуля и предупреждает о потенциальных рисках при модификации.</purpose>
      <trigger>Генерируется или обновляется при любом изменении существующего файла.</trigger>
      <template>
        <![CDATA[
# START_CHANGE_SUMMARY
# LAST_CHANGE: [Краткое описание самого последнего значимого изменения.]
# PREV_CHANGE_SUMMARY: [Свертка/обобщение ключевых изменений из предыдущих версий.]
# IMPORTANT_NOTICE: [Критически важные замечания, связанные с изменениями.]
# END_CHANGE_SUMMARY
        ]]>
      </template>
    </change_summary>
  </module>
  
  <!-- =================================================================== -->
  <!-- ==                  ПРАВИЛА ДЛЯ КОМПОНЕНТОВ КОДА                 == -->
  <!-- =================================================================== -->
  <component_contracts>
    <purpose>Этот раздел определяет правила генерации "контрактов" для отдельных сущностей кода (функций, классов).</purpose>

    <function_contract>
      <purpose>Определяет полный, но гибкий набор правил для документирования одной функции.</purpose>

      <main_purpose>
        <trigger>Обязательно для любой функции, даже однострочной.</trigger>
        <template>
          <![CDATA[
# CONTRACT:
# PURPOSE: [Краткое описание того, что функция делает, ее основная ответственность.]
          ]]>
        </template>
      </main_purpose>

      <inputs>
        <trigger>Генерируется, если у функции есть аргументы.</trigger>
        <template>
          <![CDATA[
# INPUTS:
#   - [Описание аргумента1 и его назначения.] => [имя_аргумента1]: [ТипДанных]
          ]]>
        </template>
      </inputs>

      <outputs>
        <trigger>Генерируется, если функция имеет явный `return` (кроме `return None` в конце).</trigger>
        <template>
          <![CDATA[
# OUTPUTS:
#   - [ТипВозвращаемогоЗначения] - [Описание того, что функция возвращает и в каком виде.]
          ]]>
        </template>
      </outputs>
      
      <side_effects>
        <trigger>Генерируется, если функция изменяет состояние вне своей области видимости (глобальные переменные, файлы, БД) и это неочевидно из ее названия.</trigger>
        <template>
          <![CDATA[
# SIDE_EFFECTS:
#   - [Описание побочного эффекта 1.]
          ]]>
        </template>
      </side_effects>

      <test_conditions>
        <trigger>Генерируется для функций со сложной логикой, множеством ветвлений или неочевидными граничными условиями.</trigger>
        <template>
          <![CDATA[
# TEST_CONDITIONS_SUCCESS_CRITERIA:
#   - [Условие 1 для корректного выполнения.]
#   - [Граничное условие 2, которое важно проверить.]
          ]]>
        </template>
      </test_conditions>

      <metadata>
        <trigger>Генерируется для всех публичных или ключевых внутренних функций.</trigger>
        <template>
          <![CDATA[
# KEYWORDS: [Keyword1, KnowledgeDomain2, Pattern3]
# LINKS: [RelatedFunction1, Module2, ExternalService3]
          ]]>
        </template>
      </metadata>
      
      <ai_reflection>
        <purpose>Метакогнитивная "записка на полях" от AI-генератора для будущих AI-редакторов. Фиксирует ключевые решения и компромиссы.</purpose>
        <trigger>Генерируется, если в процессе создания кода AI столкнулся с неожиданной сложностью, принял важное архитектурное решение или пошел на компромисс.</trigger>
        <template>
          <![CDATA[
# AI_REFLECTION: [SCORE: Q=9, R=8, M=7] [NOTE: Ключевым решением было ..., так как это позволило ...]
          ]]>
        </template>
      </ai_reflection>
    </function_contract>

    <class_contract>
      <purpose>Определяет правила документирования класса.</purpose>
      <reuse rule="function_contract.main_purpose"/>
      <attributes>
          <trigger>Генерируется, если у класса есть публичные атрибуты, требующие пояснения.</trigger>
          <template>
            <![CDATA[
# ATTRIBUTES:
#   - [Описание атрибута1.] => [имя_атрибута1]: [ТипДанных] 
            ]]>
          </template>
      </attributes>
      <methods_summary>
        <purpose>Мини-карта ключевых публичных методов класса.</purpose>
        <trigger>Генерируется для классов с более чем 3-4 публичными методами.</trigger>
        <template>
          <![CDATA[
# METHODS:
#   - [Краткое описание назначения метода 1.] => [имя_метода1()]
          ]]>
        </template>
      </methods_summary>
      <reuse rule="function_contract.metadata"/>
      <reuse rule="function_contract.ai_reflection"/>
    </class_contract>
  </component_contracts>

  <!-- =================================================================== -->
  <!-- ==                   ПРАВИЛА ГЕНЕРАЦИИ ТЕЛА КОДА                 == -->
  <!-- =================================================================== -->
  <codeBodyGuidelines>
    <purpose>Эти инструкции применяются к телу любой функции или метода.</purpose>
    <instruction>
      <![CDATA[
      ИНСТРУКЦИИ ПО ОФОРМЛЕНИЮ ЛОГИЧЕСКИХ БЛОКОВ И ЛОГИРОВАНИЮ:
      1.  РАЗБИЕНИЕ НА БЛОКИ: Весь код внутри функции/метода должен быть разбит на логические блоки, обрамленные `#START_[ИМЯ_БЛОКА]` и `#END_[ИМЯ_БЛОКА]`. Имя блока должно быть уникальным в проекте.
      2.  ЛОГИРОВАНИЕ "ГИПОТЕЗЫ": Логируй значения, которые подтверждают или опровергают твое предположение (Belief State) о правильности работы кода в данном блоке.
      3.  СТРОГИЙ ФОРМАТ ЛОГА: `f"[{CLASSIFIER}][{ContextName}][{BlockName}][{OpType}] Description [STATUS]"`
          - CLASSIFIER: VarCheck, SanityCheck, APICall, PerfCheck, StateChange.
          - ContextName: FunctionName или ClassName.MethodName.
          - OpType: Params, Condition, Return, Call, Exception, Step.
          - STATUS: SUCCESS, FAIL, ATTEMPT, INFO, VALUE, ERROR.
      ]]>
    </instruction>
    <template>
      <![CDATA[
def @FunctionName([аргументы]) -> [ReturnType]:
    """
    [Однострочное, очень краткое описание функции на русском для векторного поиска.]
    """
    # ... здесь генерируется код с логическими блоками и логированием по правилам выше ...
      ]]>
    </template>
  </codeBodyGuidelines>

</semanticCodeSchema>