# Правила Динамического Детального Логирования

**Основной принцип:** Когда вы (AI-агент) сталкиваетесь с "упорной ошибкой" (проблема, локализованная в небольшом участке кода, которая не поддается исправлению с нескольких попыток), вы должны использовать следующие эвристики для внедрения временного, сверхдетального логирования. Цель — собрать точную информацию о состоянии среды выполнения в точке сбоя.

---

**I. Эвристики Логирования (Что и как логировать):**

1.  **Эвристика: "Глубокое Погружение во Ввод/Вывод Функции"**
    *   **Триггер:** Проблема возникает внутри функции/метода, или ее возвращаемое значение неожиданно.
    *   **Действие:**
        *   В самом начале: `logger.debug(f"[DYNAMIC_LOG][{func_name}][ENTRY] Args: {{arg1!r}}, {{arg2!r}}, ..., Self state: {{self.__dict__!r}}")` (используя `!r` для `repr()`).
        *   Перед каждым `return`: `logger.debug(f"[DYNAMIC_LOG][{func_name}][EXIT] Returning: {{return_value!r}}")`.
    *   **Цель:** Проверить точные входные данные, изменение состояния объекта и точное возвращаемое значение.

2.  **Эвристика: "Условие под Микроскопом"**
    *   **Триггер:** Подозрение на некорректное поведение `if/elif/else` или `while`.
    *   **Действие:**
        *   Непосредственно перед условием, логировать саму строку условия и значения ВСЕХ переменных в нем: `logger.debug(f"[DYNAMIC_LOG][{func_name}][{block}][PROBE] Cond: 'var_a > 10'. Values: var_a={var_a!r}")`.
        *   Для сложных условий, разбить их на части и логировать результат каждой: `part1 = (a > b); part2 = (c is None); logger.debug(f"... Parts: part1={part1}, part2={part2}")`.
    *   **Цель:** Точно определить, почему условие вычисляется не так, как ожидалось.

3.  **Эвристика: "Аутопсия Объекта перед Операцией"**
    *   **Триггер:** Ошибка в строке, где вызывается метод или атрибут объекта (`obj.method()`).
    *   **Действие:** Перед этой строкой логировать ключевые атрибуты объекта: `logger.debug(f"[DYNAMIC_LOG][...][STATE_PROBE] Obj '{obj_name}' before op: {{obj.__dict__!r}}")`.
    *   **Цель:** Убедиться, что объект находится в ожидаемом состоянии.

4.  **Эвристика: "Отслеживание Присваивания"**
    *   **Триггер:** Значение переменной неожиданно или необъяснимо меняется.
    *   **Действие:** Найти последнее присваивание этой переменной. Логировать правую часть выражения и результат: `val = ...; logger.debug(f"... Assigning to 'my_var'. Evaluated to: {val!r}"); my_var = val`.
    *   **Цель:** Понять, как именно переменная получила свое некорректное значение.

5.  **Эвристика: "Проверка Здоровья Фреймворка/Зависимости"**
    *   **Триггер:** Ошибка во время вызова функции фреймворка/библиотеки.
    *   **Действие:**
        1.  Перед проблемным вызовом вставить "дымовой тест" (smoke test) — вызов простой, безопасной функции той же библиотеки: `logger.debug(f"... FRAMEWORK_SMOKE_TEST to 'framework.get_status()'"); try: status = framework.get_status(); ... except ...`.
        2.  **Если есть подозрения на несовместимость версии или неправильное использование API, используйте `context7`, чтобы запросить примеры кода для конкретной версии библиотеки, указанной в `requirements.txt`.**
    *   **Цель:** Изолировать проблему: она в логике приложения или в самой зависимости?

6.  **Эвристика: "Полная Прозрачность Внешнего I/O"**
    *   **Триггер:** Ошибка при вызове API, запросе к БД, чтении/записи файла.
    *   **Действие:** Логировать **все** параметры запроса (URL, заголовки, тело, SQL-запрос) до вызова и **весь** ответ (код статуса, тело, сообщение об ошибке) после. **Маскировать чувствительные данные.**
    *   **Цель:** Получить полную картину взаимодействия с внешней системой.

7.  **Эвристика: "Охота на Призрачное Исключение"**
    *   **Триггер:** Подозрение, что исключение перехватывается и "проглатывается" где-то выше по стеку.
    *   **Действие:** Обернуть проблемный блок в `try...except Exception as e: logger.error(f"... CAUGHT_PROBE: {e!r}", exc_info=True); raise`.
    *   **Цель:** Поймать и залогировать любое исключение, которое могло быть скрыто.

8.  **Эвристика: "Трассировка Итераций Цикла"**
    *   **Триггер:** Проблема внутри цикла `for` или `while`.
    *   **Действие:** В начале каждой итерации логировать ее номер и значения ключевых переменных: `logger.debug(f"... LOOP_ITERATION {i}. Item: {item!r}. Control_var: {control_var!r}")`.
    *   **Цель:** Понять, как меняются данные от итерации к итерации.

---

**II. Протокол Применения и Очистки:**

1.  **Приоритезация:** Начинайте с наиболее релевантной эвристики.
2.  **Контекстные теги:** Все динамические логи должны иметь тег `[DYNAMIC_LOG]` для легкого поиска.
3.  **Итерация:** После добавления логов, перезапустите код, проанализируйте новый вывод и, при необходимости, примените другую эвристику.
4.  **Безопасность:** Логи не должны изменять бизнес-логику.
5.  **Действия после отладки (КРИТИЧЕСКИ ВАЖНО):**
    *   **При успехе:**
        1.  **Оставить комментарий:** Перед исправленным кодом вставить комментарий `# BUG_FIX_CONTEXT:`, объясняющий суть проблемы и ее решение.
        2.  **Удалить временные логи:** Удалить все `[DYNAMIC_LOG]`, которые были нужны только для поиска.
        3.  **Сохранить полезные логи:** Закомментировать (`# RETAINED_DEBUG_LOG: ...`) самые полезные логи для будущего.
    *   **При неудаче:**
        1.  Сообщить о невозможности исправить ошибку.
        2.  Закомментировать все добавленные логи (`# DYNAMIC_LOG_ATTEMPT: ...`), чтобы оставить след попытки.

---

**III. Триггер для Динамического Логирования:**

Вы должны инициировать динамическое логирование, если:
*   Вы локализовали ошибку в 1-5 строках кода.
*   ~2-3 прямые попытки исправления не увенчались успехом.
*   Существующие логи не дают достаточно информации.
*   Вы должны явно заявить о своем намерении: "Я не могу решить проблему. Я добавлю динамическое логирование в `function_name` с помощью эвристики 'Название Эвристики', чтобы проверить состояние переменных."